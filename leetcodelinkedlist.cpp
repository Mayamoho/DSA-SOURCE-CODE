//Collection of some easy and medium difficulty leetcode problems solved by me
/*#include<bits/stdc++.h>
using namespace std;
//1.Let's create a polynomial from scratch!
struct node{
    int co;
    int ex;
    node* link;
};
//inserting element in descending order
node* head = NULL;
void insert(int co, int ex){
    node* temp = new node();
    temp-> co = co;
    temp-> ex = ex;
    temp-> link = NULL;
    int key = ex;
    if(head == NULL || head-> ex < key){
    temp-> link = head;
    head = temp;
}
    else{
        node* ptr = head;
        //This part resembles insertion at specific position including the end of linked list
        while(ptr-> link!=NULL && ptr-> link -> ex > key)
            ptr = ptr-> link;
            temp-> link = ptr-> link;
            ptr-> link = temp;
    }

}
void print(){
    if(head == NULL)
    cout << "Polynomial is empty\n";
    else{
        node* ptr = head;
        while(ptr){
            if(ptr-> ex!=0)
            cout << ptr-> co << "x^" << ptr-> ex;
            else
            cout << ptr-> co;
            ptr = ptr-> link;
            if(ptr)
            cout << "+";
            else
            cout << "\n";
        }
    }
}
int main(){
    int n;
    cin >> n;
    while(n--){
        int data1, data2;
        cin >> data1 >> data2;
        insert(data1, data2);
    }
    print();
}*/
//2.
//remove all instances of a node in a singly linked list
//Just writing the logic, language can be C/C++/Java
/**
 * Definition for singly-linked list.
 * //This part is generated by leetcode
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
//This is the solution written by me
/*class Solution {
public:
    ListNode* removeElements(ListNode* head, int x) {
        ListNode* ptr = head; 
       if(head-> val == x)
       head = head-> next;
       while(ptr->next){
      if(ptr->next->val == x){
         ptr-> next = ptr-> next->next;
         break;
      }
      ptr = ptr-> next;
   }
    return head;
};*/
/**
 * //3. Remove duplicates from sorted linked list
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
/*class Solution {
public:
    ListNode* deleteDuplicates(ListNode* head) {
        ListNode* temp = head;
        if(head == NULL)
        return head;
        else{
            while(temp-> next){
                if(temp-> next-> val == temp-> val)
                temp-> next = temp-> next-> next;
                else
                temp = temp-> next;
            }
        }
        return head;
    }
};*/
//4. Middle node of the linked list
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
//using hare and tortoise algorithm i.e fast and slow pointer
/*class Solution {
public:
    ListNode* middleNode(ListNode* head) {
         ListNode* fast = head;
         ListNode* slow = head;
    while(fast!=NULL && fast-> next!=NULL){
        slow = slow-> next;
        fast = fast-> next-> next;
    }
    return slow;
    }
};*/
//5. Merge two sorted lists
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     struct ListNode *next;
 * };
 */
/*struct ListNode* mergeTwoLists(struct ListNode* list1, struct ListNode* list2) {
    struct ListNode* temp = (struct ListNode*)malloc(sizeof(struct ListNode));
       struct ListNode* ptr = temp;
       struct ListNode* ptr1 = list1;
        struct ListNode* ptr2 = list2;
        while(ptr1!=NULL && ptr2!=NULL){
            if(ptr1->val<=ptr2->val){
                temp-> next = ptr1;
                ptr1 = ptr1-> next;
            }
            else{
                temp-> next = ptr2;
                ptr2 = ptr2-> next;
            }
            temp = temp-> next;
        }
        if(ptr1==NULL)
        temp-> next = ptr2;
        else if(ptr2==NULL)
        temp-> next = ptr1;
        return ptr-> next;
}*/
// 6. Check if a linked list is palindrome
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
/*class Solution {
public:
    bool isPalindrome(ListNode* head) {
        //finding the middle node
        ListNode* fast = head;
        ListNode* slow = head;
        while(fast!=NULL && fast-> next!=NULL){
            slow = slow-> next;
            fast = fast-> next-> next;
        }
        if(fast!=NULL)
        slow = slow-> next;
        //reversing from middle to last node
        ListNode* prev = NULL;
        ListNode* notun = NULL;
        while(slow){
            notun = slow-> next;
            slow-> next = prev;
            prev = slow;
            slow = notun;
        }
            slow = prev;
            fast = head;
            //comparing values from first to middle nodes and reversed nodes
            while(slow){
                if(slow-> val!=fast-> val)
                return false;
                slow = slow-> next;
                fast = fast-> next;
            }
            return true;
    }
};*/
// 7. reverse of a singly linked list
/*struct ListNode* reverseList(struct ListNode* head) {
   struct ListNode* prev = NULL;
   struct ListNode* notun = NULL;
    if(head==NULL)
    printf("Linked list is empty\n");
    while(head){
        notun = head-> next;
        head-> next = prev;
        prev = head;
        head = notun;
    }
    head = prev;
    return head;
}*/
// 8. intersection of two singly linked lists
/*ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        ListNode* ptr1 = ptr1;
        ListNode* ptr2 = ptr2;
        int len1 = getListLength(ptr1);
        int len2 = getListLength(ptr2);
        if(len1>len2){
            len1--;
            ptr1 = ptr1-> next;
        }
        if(len1<len2){
            len2--;
            ptr2 = ptr2-> next;
        }
        while(ptr1!=ptr2){
            ptr1 = ptr1-> next;
            ptr2 = ptr2-> next;
        }
        return ptr1;
    }
     int getListLength(ListNode* head){
        int count=0;
        if(head == NULL)
        cout << "Linked list is empty\n";
        else{
            ListNode* ptr = head;
            while(ptr){
                count++;
                ptr=ptr-> next;
            }
        }
        return count;
    } */
