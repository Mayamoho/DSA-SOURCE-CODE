//Collection of some easy and medium difficulty leetcode problems solved by me
/*#include<bits/stdc++.h>
using namespace std;
//1.Let's create a polynomial from scratch!
struct node{
    int co;
    int ex;
    node* link;
};
//inserting element in descending order
node* head = NULL;
void insert(int co, int ex){
    node* temp = (node*)malloc(sizeof(node));
    temp-> co = co;
    temp-> ex = ex;
    temp-> link = NULL;
    int key = ex;
    if(head == NULL || head-> ex <key){
    temp-> link = head;
    head = temp;
}
    else{
        node* ptr = head;
        //This part resembles insertion at specific position including the end of linked list
        while(ptr-> link!=NULL && ptr-> link -> ex >key)
            ptr = ptr-> link;
            temp-> link = ptr-> link;
            ptr-> link = temp;
    }

}
void print(){
    if(head == NULL)
    cout << "Polynomial is empty\n";
    else{
        node* ptr = head;
        while(ptr!=NULL){
            if(ptr-> ex!=0)
            cout << ptr-> co << "x^" << ptr-> ex;
            else
            cout << ptr-> co;
            ptr = ptr-> link;
            if(ptr!=NULL)
            cout << "+";
            else
            cout << "\n";
        }
    }
}
int main(){
    int n;
    cin >> n;
    while(n--){
        int data1, data2;
        cin >> data1 >> data2;
        insert(data1, data2);
    }
    print();
}*/
//2.
//remove all instances of a node in a singly linked list
//Just writing the logic, language can be C/C++/Java
/**
 * Definition for singly-linked list.
 * //This part is generated by leetcode
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
//This is the solution written by me
/*class Solution {
public:
    ListNode* removeElements(ListNode* head, int x) {
        ListNode* dummy = new ListNode();
        dummy-> next = head;
        ListNode* ptr = dummy;
        while(ptr-> next){
        if(ptr-> next->val == x){
         ptr->  next = ptr->  next->  next;
      }
      else
      ptr = ptr->  next;
   }
      return dummy-> next;
    }
};*/
/**
 * //3. Remove duplicates from sorted linked list
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
/*class Solution {
public:
    ListNode* deleteDuplicates(ListNode* head) {
        ListNode* temp = head;
        if(head == NULL)
        return head;
        else{
            while(temp-> next){
                if(temp-> next-> val == temp-> val)
                temp-> next = temp-> next-> next;
                else
                temp = temp-> next;
            }
        }
        return head;
    }
};*/
//4. Middle node of the linked list
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
//using hare and tortoise algorithm i.e fast and slow pointer
/*class Solution {
public:
    ListNode* middleNode(ListNode* head) {
         ListNode* fast = head;
         ListNode* slow = head;
    while(fast!=NULL && fast-> next!=NULL){
        slow = slow-> next;
        fast = fast-> next-> next;
    }
    return slow;
    }
};*/
//5. Merge two sorted lists
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     struct ListNode *next;
 * };
 */
/*struct ListNode* mergeTwoLists(struct ListNode* list1, struct ListNode* list2) {
    struct ListNode* temp = (struct ListNode*)malloc(sizeof(struct ListNode));
       struct ListNode* ptr = temp;
       struct ListNode* ptr1 = list1;
        struct ListNode* ptr2 = list2;
        while(ptr1!=NULL && ptr2!=NULL){
            if(ptr1->val<=ptr2->val){
                temp-> next = ptr1;
                ptr1 = ptr1-> next;
            }
            else{
                temp-> next = ptr2;
                ptr2 = ptr2-> next;
            }
            temp = temp-> next;
        }
        if(ptr1==NULL)
        temp-> next = ptr2;
        else if(ptr2==NULL)
        temp-> next = ptr1;
        return ptr-> next;
}*/